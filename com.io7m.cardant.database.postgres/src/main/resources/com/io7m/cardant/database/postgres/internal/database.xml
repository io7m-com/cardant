<?xml version="1.0" encoding="UTF-8" ?>

<Schemas xmlns="urn:com.io7m.trasco.database.statements:1:0">

  <Parameters>
    <Parameter name="search.language"
               type="STRING"/>
  </Parameters>

  <Schema versionCurrent="0">
    <Comment>
      The cardant role is a least-privilege role that can perform only those
      operations required to run the system and no others.
    </Comment>

    <Statement><![CDATA[
DROP ROLE IF EXISTS cardant;
]]></Statement>
    <Statement><![CDATA[
CREATE ROLE cardant WITH NOSUPERUSER NOCREATEDB NOCREATEROLE NOINHERIT NOLOGIN;
]]></Statement>

    <Comment>
      The cardant_none role is a no-privilege role that cannot perform any
      actions.
    </Comment>

    <Statement><![CDATA[
DROP ROLE IF EXISTS cardant_none;
]]></Statement>
    <Statement><![CDATA[
CREATE ROLE cardant_none WITH NOSUPERUSER NOCREATEDB NOCREATEROLE NOINHERIT NOLOGIN;
]]></Statement>

    <Comment>
      The cardant_read_only role is a read-only role that cannot write to
      anything.
    </Comment>

    <Statement><![CDATA[
DROP ROLE IF EXISTS cardant_read_only;
]]></Statement>
    <Statement><![CDATA[
CREATE ROLE cardant_read_only WITH NOSUPERUSER NOCREATEDB NOCREATEROLE NOINHERIT NOLOGIN;
]]></Statement>

    <Comment>
      The schema version table stores the current version of the database
      schema. Implementations are expected to query this table on connecting to
      the database in order to ensure that the calling code is compatible with
      the tables in the database.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE SCHEMA_VERSION (
  VERSION_LOCK            CHAR(1) NOT NULL DEFAULT 'X',
  VERSION_APPLICATION_ID  TEXT    NOT NULL,
  VERSION_NUMBER          BIGINT  NOT NULL,

  CONSTRAINT CHECK_LOCK_PRIMARY PRIMARY KEY (VERSION_LOCK),
  CONSTRAINT CHECK_LOCK_LOCKED CHECK (VERSION_LOCK = 'X')
)
]]>
    </Statement>
  </Schema>

  <Schema versionCurrent="1">
    <Comment>
      The USERS table stores the current set of users. The name field is neither
      authoritative, nor expected to be unique, because the external identity
      server is the authoritative source for names.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE USERS (
  ID    UUID   NOT NULL PRIMARY KEY,
  NAME  TEXT   NOT NULL,
  ROLES TEXT[] NOT NULL
)
]]></Statement>

    <Statement>
      GRANT SELECT, INSERT, UPDATE ON USERS TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON USERS TO cardant_read_only
    </Statement>

    <Comment>
      The TAGS table contains the list of tags.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE TAGS (
  TAG_ID    UUID         NOT NULL PRIMARY KEY,
  TAG_NAME  VARCHAR(128) NOT NULL,

  CONSTRAINT UNIQUE_TAGS UNIQUE (TAG_NAME)
)
]]></Statement>

    <Statement>
      GRANT SELECT, INSERT, UPDATE, DELETE ON TAGS TO cardant
    </Statement>
    <Statement>GRANT SELECT ON TAGS TO cardant_read_only</Statement>

    <Comment>
      The FILES table contains files.
    </Comment>

    <StatementParameterized parameterInterpolation="STRING_FORMATTING">
      <ParameterReferences>
        <ParameterReference order="0"
                            name="search.language"/>
      </ParameterReferences>
      <Text>
        <![CDATA[
CREATE TABLE FILES (
  ID                 UUID          NOT NULL PRIMARY KEY,
  DESCRIPTION        VARCHAR(256)  NOT NULL,
  -- [jooq ignore start]
  DESCRIPTION_SEARCH TSVECTOR      NOT NULL
    GENERATED ALWAYS AS (TO_TSVECTOR(%S, DESCRIPTION)) STORED,
  -- [jooq ignore stop]
  MEDIA_TYPE         VARCHAR(128)  NOT NULL,
  HASH_ALGORITHM     VARCHAR(32)   NOT NULL,
  HASH_VALUE         VARCHAR(256)  NOT NULL,
  DATA               BYTEA         NOT NULL,
  DATA_USED          BIGINT        NOT NULL,

  CONSTRAINT CHECK_NATURAL_DATA CHECK (DATA_USED >= 0)
)
]]></Text>
    </StatementParameterized>

    <Statement>
      GRANT SELECT, INSERT, UPDATE, DELETE ON FILES TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON FILES TO cardant_read_only
    </Statement>

    <Comment>
      The METADATA_TYPE_DECLARATIONS table contains type declarations. A type
      declaration essentially consists of a set of typed fields.
    </Comment>

    <StatementParameterized parameterInterpolation="STRING_FORMATTING">
      <ParameterReferences>
        <ParameterReference order="0"
                            name="search.language"/>
      </ParameterReferences>
      <Text><![CDATA[
CREATE TABLE METADATA_TYPE_DECLARATIONS (
  ID                  INTEGER        NOT NULL PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  NAME                VARCHAR(1024)  NOT NULL UNIQUE,
  DESCRIPTION         VARCHAR(1024)  NOT NULL,
  -- [jooq ignore start]
  DESCRIPTION_SEARCH  TSVECTOR       NOT NULL
    GENERATED ALWAYS AS (TO_TSVECTOR(%S, DESCRIPTION)) STORED,
  -- [jooq ignore stop]

  CONSTRAINT METADATA_TYPE_DECLARATION_NAME_VALID
    CHECK (NAME ~ '^([a-z][a-z0-9_-]{0,63})(\.[a-z][a-z0-9_-]{0,62}){0,15}$')
)
]]></Text>
    </StatementParameterized>

    <Statement>
      GRANT SELECT, INSERT, UPDATE, DELETE ON METADATA_TYPE_DECLARATIONS TO
      cardant
    </Statement>
    <Statement>
      GRANT SELECT ON METADATA_TYPE_DECLARATIONS TO cardant_read_only
    </Statement>

    <Comment>
      The METADATA_SCALAR_TYPES table describes the scalar types that can be
      assigned to fields.
    </Comment>

    <StatementParameterized parameterInterpolation="STRING_FORMATTING">
      <ParameterReferences>
        <ParameterReference order="0"
                            name="search.language"/>
      </ParameterReferences>
      <Text><![CDATA[
CREATE TABLE METADATA_SCALAR_TYPES (
  ID                  INTEGER        NOT NULL PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  NAME                VARCHAR(1024)  NOT NULL UNIQUE,
  DESCRIPTION         VARCHAR(1024)  NOT NULL,
  -- [jooq ignore start]
  DESCRIPTION_SEARCH  TSVECTOR       NOT NULL
    GENERATED ALWAYS AS (TO_TSVECTOR(%S, DESCRIPTION)) STORED,
  -- [jooq ignore stop]
  PATTERN             VARCHAR(1024)  NOT NULL,

  CONSTRAINT METADATA_SCALAR_TYPES_NAME_VALID
    CHECK (NAME ~ '^([a-z][a-z0-9_-]{0,63})(\.[a-z][a-z0-9_-]{0,62}){0,15}$')
)
]]></Text>
    </StatementParameterized>

    <Statement>
      GRANT SELECT, INSERT, UPDATE, DELETE ON METADATA_SCALAR_TYPES TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON METADATA_SCALAR_TYPES TO cardant_read_only
    </Statement>

    <Comment>
      The METADATA_TYPE_DECLARATION_FIELDS table associates fields with type
      declarations.
    </Comment>

    <StatementParameterized parameterInterpolation="STRING_FORMATTING">
      <ParameterReferences>
        <ParameterReference order="0"
                            name="search.language"/>
      </ParameterReferences>
      <Text><![CDATA[
CREATE TABLE METADATA_TYPE_FIELDS (
  FIELD_DECLARATION         INTEGER        NOT NULL,
  FIELD_SCALAR_TYPE         INTEGER        NOT NULL,
  FIELD_NAME                VARCHAR(1024)  NOT NULL,
  FIELD_DESCRIPTION         VARCHAR(1024)  NOT NULL,
  -- [jooq ignore start]
  FIELD_DESCRIPTION_SEARCH  TSVECTOR       NOT NULL
    GENERATED ALWAYS AS (TO_TSVECTOR(%S, FIELD_DESCRIPTION)) STORED,
  -- [jooq ignore stop]
  FIELD_REQUIRED            BOOLEAN        NOT NULL,

  PRIMARY KEY (FIELD_DECLARATION, FIELD_NAME),

  CONSTRAINT FIELD_NAME_VALID
    CHECK (FIELD_NAME ~ '^([a-z][a-z0-9_-]{0,63})(\.[a-z][a-z0-9_-]{0,62}){0,15}$'),

  CONSTRAINT FIELD_DECLARATION_EXISTS
    FOREIGN KEY (FIELD_DECLARATION) REFERENCES METADATA_TYPE_DECLARATIONS (ID),

  CONSTRAINT FIELD_SCALAR_TYPE_EXISTS
    FOREIGN KEY (FIELD_SCALAR_TYPE) REFERENCES METADATA_SCALAR_TYPES (ID)
)
]]></Text>
    </StatementParameterized>

    <Statement>
      GRANT SELECT, INSERT, UPDATE, DELETE ON METADATA_TYPE_FIELDS TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON METADATA_TYPE_FIELDS TO cardant_read_only
    </Statement>

    <Comment>
      The ITEMS table contains the list of items.
    </Comment>

    <StatementParameterized parameterInterpolation="STRING_FORMATTING">
      <ParameterReferences>
        <ParameterReference order="0"
                            name="search.language"/>
      </ParameterReferences>
      <Text><![CDATA[
CREATE TABLE ITEMS (
  ITEM_ID       UUID          NOT NULL PRIMARY KEY,
  ITEM_NAME     VARCHAR(1024) NOT NULL,
  -- [jooq ignore start]
  ITEM_NAME_SEARCH TSVECTOR NOT NULL
    GENERATED ALWAYS AS (TO_TSVECTOR(%S, ITEM_NAME)) STORED,
  -- [jooq ignore stop]
  ITEM_DELETED  BOOLEAN       NOT NULL
)
]]></Text>
    </StatementParameterized>

    <Statement>
      GRANT SELECT, INSERT, UPDATE, DELETE ON ITEMS TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON ITEMS TO cardant_read_only
    </Statement>

    <Comment>
      The ITEM_TYPES table assigns types to items. An item can have zero or more
      types.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE ITEM_TYPES (
  ITEM               UUID     NOT NULL,
  TYPE_DECLARATION   INTEGER  NOT NULL,

  PRIMARY KEY (ITEM, TYPE_DECLARATION),

  CONSTRAINT ITEM_TYPES_ITEM_EXISTS
    FOREIGN KEY (ITEM) REFERENCES ITEMS (ITEM_ID),

  CONSTRAINT ITEM_TYPES_DECLARATION_EXISTS
    FOREIGN KEY (TYPE_DECLARATION) REFERENCES METADATA_TYPE_DECLARATIONS (ID)
)
]]></Statement>

    <Statement>
      GRANT SELECT, INSERT, UPDATE, DELETE ON ITEM_TYPES TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON ITEM_TYPES TO cardant_read_only
    </Statement>

    <Comment>
      The ITEM_TAGS table contains the tags applied to each item.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE ITEM_TAGS (
  TAG_ITEM_ID  UUID NOT NULL,
  TAG_ID       UUID NOT NULL,

  CONSTRAINT UNIQUE_TAGGING
    UNIQUE (TAG_ITEM_ID, TAG_ID),

  CONSTRAINT TAG_ITEM_EXISTS
    FOREIGN KEY (TAG_ITEM_ID) REFERENCES ITEMS (ITEM_ID),

  CONSTRAINT TAG_TAG_EXISTS
    FOREIGN KEY (TAG_ID) REFERENCES TAGS (TAG_ID)
)
]]></Statement>

    <Statement>
      GRANT SELECT, INSERT, UPDATE, DELETE ON ITEM_TAGS TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON ITEM_TAGS TO cardant_read_only
    </Statement>

    <Comment>
      The ITEM_ATTACHMENTS table contains attachments for each item.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE ITEM_ATTACHMENTS (
  FILE_ID   UUID         NOT NULL,
  ITEM_ID   UUID         NOT NULL,
  RELATION  VARCHAR(128) NOT NULL,

  CONSTRAINT FILE_EXISTS
    FOREIGN KEY (FILE_ID) REFERENCES FILES (ID),

  CONSTRAINT ITEM_EXISTS
    FOREIGN KEY (ITEM_ID) REFERENCES ITEMS (ITEM_ID),

  PRIMARY KEY (FILE_ID, ITEM_ID, RELATION)
)
]]></Statement>

    <Statement>
      GRANT SELECT, INSERT, UPDATE, DELETE ON ITEM_ATTACHMENTS TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON ITEM_ATTACHMENTS TO cardant_read_only
    </Statement>

    <Comment>
      The ITEM_METADATA table contains metadata for each item.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE ITEM_METADATA (
  METADATA_ITEM_ID  UUID          NOT NULL,
  METADATA_NAME     VARCHAR(1024) NOT NULL,
  METADATA_VALUE    VARCHAR(1024) NOT NULL,

  CONSTRAINT METADATA_NAME_VALID
    CHECK (METADATA_NAME ~ '^([a-z][a-z0-9_-]{0,63})(\.[a-z][a-z0-9_-]{0,62}){0,15}$'),

  CONSTRAINT METADATA_ITEM_EXISTS
    FOREIGN KEY (METADATA_ITEM_ID) REFERENCES ITEMS (ITEM_ID),

  CONSTRAINT METADATA_NAME_UNIQUE
    UNIQUE (METADATA_ITEM_ID, METADATA_NAME)
)
]]></Statement>

    <Statement>
      GRANT SELECT, INSERT, UPDATE, DELETE ON ITEM_METADATA TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON ITEM_METADATA TO cardant_read_only
    </Statement>

    <Comment>
      The METADATA_ELEMENT_T type holds a metadata value. This type is used
      as a strongly-typed container for values during search operations.
    </Comment>

    <Statement><![CDATA[
-- [jooq ignore start]
CREATE TYPE METADATA_ELEMENT_T AS (
  NAME  VARCHAR(1024),
  VALUE VARCHAR(1024)
)
-- [jooq ignore stop]
]]></Statement>

    <Comment>
      The LOCATIONS table contains storage/deployment locations for each item.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE LOCATIONS (
  LOCATION_ID           UUID          NOT NULL PRIMARY KEY,
  LOCATION_PARENT       UUID,
  LOCATION_NAME         VARCHAR(128)  NOT NULL,
  LOCATION_DESCRIPTION  VARCHAR(1024) NOT NULL,

  CONSTRAINT LOCATION_PARENT_EXISTS
    FOREIGN KEY (LOCATION_PARENT) REFERENCES LOCATIONS (LOCATION_ID)
)
]]></Statement>

    <Statement>
      GRANT SELECT, INSERT, UPDATE, DELETE ON LOCATIONS TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON LOCATIONS TO cardant_read_only
    </Statement>

    <Statement><![CDATA[
CREATE TABLE ITEM_LOCATIONS (
  ITEM_ID              UUID   NOT NULL,
  ITEM_LOCATION        UUID   NOT NULL,
  COUNT                BIGINT NOT NULL,

  PRIMARY KEY (ITEM_ID, ITEM_LOCATION),

  CONSTRAINT ITEM_ID_EXISTS
    FOREIGN KEY (ITEM_ID) REFERENCES ITEMS (ITEM_ID),

  CONSTRAINT ITEM_LOCATION_EXISTS
    FOREIGN KEY (ITEM_LOCATION) REFERENCES LOCATIONS (LOCATION_ID),

  CONSTRAINT CHECK_ITEM_LOCATION_COUNT CHECK (COUNT >= 0)
)
]]></Statement>

    <Statement>
      GRANT SELECT, INSERT, UPDATE, DELETE ON ITEM_LOCATIONS TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON ITEM_LOCATIONS TO cardant_read_only
    </Statement>

    <Statement><![CDATA[
CREATE VIEW ITEM_LOCATIONS_SUMMED (ITEM_ID, ITEM_COUNT)
  AS SELECT IL.ITEM_ID, SUM (IL.COUNT) FROM ITEM_LOCATIONS AS IL
    GROUP BY IL.ITEM_ID
]]></Statement>

    <Statement>
      GRANT SELECT ON ITEM_LOCATIONS_SUMMED TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON ITEM_LOCATIONS_SUMMED TO cardant_read_only
    </Statement>

    <Comment>
      The LOCATION_DESCENDANTS function returns the descendants of a given
      location. The location itself is included in the results.
    </Comment>

    <Statement><![CDATA[
CREATE FUNCTION LOCATION_DESCENDANTS (X UUID)
  RETURNS TABLE (LOCATION UUID)
  LANGUAGE SQL
  AS
$$
WITH RECURSIVE LOCATION_TREE AS (
  SELECT
    LOCATIONS.LOCATION_PARENT,
    LOCATIONS.LOCATION_ID
  FROM LOCATIONS
  WHERE
    LOCATIONS.LOCATION_PARENT = X
  UNION
    SELECT
      L.LOCATION_PARENT,
      L.LOCATION_ID
    FROM LOCATIONS L
    JOIN LOCATION_TREE
      ON LOCATION_TREE.LOCATION_ID = L.LOCATION_PARENT
)
SELECT
  LOCATION_ID
FROM LOCATION_TREE
UNION
  SELECT Q.LOCATION_ID
    FROM LOCATIONS Q
    WHERE Q.LOCATION_ID = X
$$
]]></Statement>

    <Comment>
      The LOCATION_DESCENDANTS function returns the descendants of a given
      location. The location itself is not included in the results.
    </Comment>

    <Statement><![CDATA[
CREATE FUNCTION LOCATION_DESCENDANTS_STRICT (X UUID)
  RETURNS TABLE (LOCATION UUID)
  LANGUAGE SQL
  AS
$$
WITH RECURSIVE LOCATION_TREE AS (
  SELECT
    LOCATIONS.LOCATION_PARENT,
    LOCATIONS.LOCATION_ID
  FROM LOCATIONS
  WHERE
    LOCATIONS.LOCATION_PARENT = X
  UNION
    SELECT
      L.LOCATION_PARENT,
      L.LOCATION_ID
    FROM LOCATIONS L
    JOIN LOCATION_TREE
      ON LOCATION_TREE.LOCATION_ID = L.LOCATION_PARENT
)
SELECT LOCATION_ID FROM LOCATION_TREE
$$
]]></Statement>

    <Comment>
      The LOCATION_IS_DESCENDANT_OF function returns true if x is a descendant
      of y in terms of the locations table.
    </Comment>

    <Statement><![CDATA[
CREATE FUNCTION LOCATION_IS_DESCENDANT_OF(
  X UUID,
  Y UUID
) RETURNS BOOL
  LANGUAGE PLPGSQL
  AS $$
BEGIN
  IF X = Y THEN
    RETURN TRUE;
  END IF;

  DECLARE
    YP UUID;
  BEGIN
    SELECT LOCATION_PARENT INTO YP FROM LOCATIONS WHERE LOCATION_ID = Y;
    RETURN LOCATION_IS_DESCENDANT_OF (X, YP);
  END;
END
$$
]]></Statement>

    <Comment>
      The AUDIT table stores a list of auditable events. Who did it? What did
      they do? When did they do it?
    </Comment>

    <Statement><![CDATA[
CREATE TABLE AUDIT (
  ID             BIGINT                   NOT NULL
    PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  USER_ID        UUID                     NOT NULL,
  TIME           TIMESTAMP WITH TIME ZONE NOT NULL,
  TYPE           VARCHAR(1000000)         NOT NULL,
  MESSAGE        VARCHAR(1000000)         NOT NULL
)
]]></Statement>

    <Statement>
      GRANT SELECT, INSERT ON AUDIT TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON AUDIT TO cardant_read_only
    </Statement>
  </Schema>
</Schemas>
