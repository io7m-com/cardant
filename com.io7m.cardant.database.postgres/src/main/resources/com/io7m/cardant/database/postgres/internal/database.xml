<?xml version="1.0" encoding="UTF-8" ?>

<Schemas xmlns="urn:com.io7m.trasco.database.statements:1:0">

  <Parameters>
    <Parameter name="search.language"
               type="STRING"/>
  </Parameters>

  <Schema versionCurrent="0">
    <Comment>
      The cardant role is a least-privilege role that can perform only those
      operations required to run the system and no others.
    </Comment>

    <Statement><![CDATA[
DROP ROLE IF EXISTS cardant;
]]></Statement>
    <Statement><![CDATA[
CREATE ROLE cardant WITH NOSUPERUSER NOCREATEDB NOCREATEROLE NOINHERIT NOLOGIN;
]]></Statement>

    <Comment>
      The cardant_none role is a no-privilege role that cannot perform any
      actions.
    </Comment>

    <Statement><![CDATA[
DROP ROLE IF EXISTS cardant_none;
]]></Statement>
    <Statement><![CDATA[
CREATE ROLE cardant_none WITH NOSUPERUSER NOCREATEDB NOCREATEROLE NOINHERIT NOLOGIN;
]]></Statement>

    <Comment>
      The cardant_read_only role is a read-only role that cannot write to
      anything.
    </Comment>

    <Statement><![CDATA[
DROP ROLE IF EXISTS cardant_read_only;
]]></Statement>
    <Statement><![CDATA[
CREATE ROLE cardant_read_only WITH NOSUPERUSER NOCREATEDB NOCREATEROLE NOINHERIT NOLOGIN;
]]></Statement>

    <Comment>
      The schema version table stores the current version of the database
      schema. Implementations are expected to query this table on connecting to
      the database in order to ensure that the calling code is compatible with
      the tables in the database.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE schema_version (
  version_lock            CHAR(1) NOT NULL DEFAULT 'X',
  version_application_id  TEXT    NOT NULL,
  version_number          BIGINT  NOT NULL,

  CONSTRAINT check_lock_primary PRIMARY KEY (version_lock),
  CONSTRAINT check_lock_locked CHECK (version_lock = 'X')
)
]]>
    </Statement>
  </Schema>

  <Schema versionCurrent="1">
    <Comment>
      The users table stores the current set of users. The name field is neither
      authoritative, nor expected to be unique, because the external identity
      server is the authoritative source for names.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE users (
  id    UUID   NOT NULL PRIMARY KEY,
  name  TEXT   NOT NULL,
  roles TEXT[] NOT NULL
)
]]></Statement>

    <Statement>
      GRANT SELECT, INSERT, UPDATE ON users TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON users TO cardant_read_only
    </Statement>

    <Comment>
      The files table contains files.
    </Comment>

    <StatementParameterized parameterInterpolation="STRING_FORMATTING">
      <ParameterReferences>
        <ParameterReference order="0"
                            name="search.language"/>
      </ParameterReferences>
      <Text>
        <![CDATA[
CREATE TABLE files (
  id          UUID         NOT NULL PRIMARY KEY,
  description VARCHAR(256) NOT NULL,

  -- [jooq ignore start]
  description_search TSVECTOR NOT NULL GENERATED ALWAYS AS (to_tsvector(%S, description)) STORED,
  -- [jooq ignore stop]

  media_type     VARCHAR(128) NOT NULL,
  hash_algorithm VARCHAR(32)  NOT NULL,
  hash_value     VARCHAR(256) NOT NULL,
  data           BYTEA        NOT NULL,
  data_used      BIGINT       NOT NULL,

  CONSTRAINT check_natural_data CHECK (data_used >= 0)
)
]]></Text>
    </StatementParameterized>

    <Statement>
      GRANT SELECT, INSERT, UPDATE, DELETE ON files TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON files TO cardant_read_only
    </Statement>

    <Comment>
      The metadata_type_declarations table contains type declarations. A type
      declaration essentially consists of a set of typed fields.
    </Comment>

    <StatementParameterized parameterInterpolation="STRING_FORMATTING">
      <ParameterReferences>
        <ParameterReference order="0"
                            name="search.language"/>
      </ParameterReferences>
      <Text><![CDATA[
CREATE TABLE metadata_type_declarations (
  id          INTEGER       NOT NULL PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  name        VARCHAR(1024) NOT NULL UNIQUE,
  description VARCHAR(1024) NOT NULL,

  -- [jooq ignore start]
  description_search TSVECTOR NOT NULL GENERATED ALWAYS AS (to_tsvector(%S, description)) STORED,
  -- [jooq ignore stop]

  CONSTRAINT metadata_type_declaration_name_valid
    CHECK (name ~ '^([a-z][a-z0-9_-]{0,63})(\.[a-z][a-z0-9_-]{0,62}){0,15}$')
)
]]></Text>
    </StatementParameterized>

    <Statement>
      GRANT SELECT, INSERT, UPDATE, DELETE ON metadata_type_declarations TO
      cardant
    </Statement>
    <Statement>
      GRANT SELECT ON metadata_type_declarations TO cardant_read_only
    </Statement>

    <Comment>
      The metadata_scalar_types table describes the scalar types that can be
      assigned to fields.
    </Comment>

    <StatementParameterized parameterInterpolation="STRING_FORMATTING">
      <ParameterReferences>
        <ParameterReference order="0"
                            name="search.language"/>
      </ParameterReferences>
      <Text><![CDATA[
CREATE TABLE metadata_scalar_types (
  id          INTEGER       NOT NULL PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  name        VARCHAR(1024) NOT NULL UNIQUE,
  description VARCHAR(1024) NOT NULL,

  -- [jooq ignore start]
  description_search TSVECTOR NOT NULL GENERATED ALWAYS AS (to_tsvector(%S, description)) STORED,
  -- [jooq ignore stop]

  pattern VARCHAR(1024) NOT NULL,

  CONSTRAINT metadata_scalar_types_name_valid
    CHECK (name ~ '^([a-z][a-z0-9_-]{0,63})(\.[a-z][a-z0-9_-]{0,62}){0,15}$')
)
]]></Text>
    </StatementParameterized>

    <Statement>
      GRANT SELECT, INSERT, UPDATE, DELETE ON metadata_scalar_types TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON metadata_scalar_types TO cardant_read_only
    </Statement>

    <Comment>
      The metadata_type_fields table associates fields with type declarations.
    </Comment>

    <StatementParameterized parameterInterpolation="STRING_FORMATTING">
      <ParameterReferences>
        <ParameterReference order="0"
                            name="search.language"/>
      </ParameterReferences>
      <Text><![CDATA[
CREATE TABLE metadata_type_fields (
  field_declaration INTEGER       NOT NULL,
  field_scalar_type INTEGER       NOT NULL,
  field_name        VARCHAR(1024) NOT NULL,
  field_description VARCHAR(1024) NOT NULL,

  -- [jooq ignore start]
  field_description_search TSVECTOR NOT NULL GENERATED ALWAYS AS (to_tsvector(%S, field_description)) STORED,
  -- [jooq ignore stop]

  field_required BOOLEAN NOT NULL,

  PRIMARY KEY (field_declaration, field_name),

  CONSTRAINT field_name_valid
    CHECK (field_name ~ '^([a-z][a-z0-9_-]{0,63})(\.[a-z][a-z0-9_-]{0,62}){0,15}$'),

  CONSTRAINT field_declaration_exists
    FOREIGN KEY (field_declaration) REFERENCES metadata_type_declarations (id),

  CONSTRAINT field_scalar_type_exists
    FOREIGN KEY (field_scalar_type) REFERENCES metadata_scalar_types (id)
)
]]></Text>
    </StatementParameterized>

    <Statement>
      GRANT SELECT, INSERT, UPDATE, DELETE ON metadata_type_fields TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON metadata_type_fields TO cardant_read_only
    </Statement>

    <Comment>
      The items table contains the list of items.
    </Comment>

    <StatementParameterized parameterInterpolation="STRING_FORMATTING">
      <ParameterReferences>
        <ParameterReference order="0"
                            name="search.language"/>
      </ParameterReferences>
      <Text><![CDATA[
CREATE TABLE items (
  item_id   UUID          NOT NULL PRIMARY KEY,
  item_name VARCHAR(1024) NOT NULL,

  -- [jooq ignore start]
  item_name_search TSVECTOR NOT NULL GENERATED ALWAYS AS (to_tsvector(%S, item_name)) STORED,
  -- [jooq ignore stop]

  item_deleted BOOLEAN NOT NULL
)
]]></Text>
    </StatementParameterized>

    <Statement>
      GRANT SELECT, INSERT, UPDATE, DELETE ON items TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON items TO cardant_read_only
    </Statement>

    <Comment>
      The item_types table assigns types to items. An item can have zero or more
      types.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE item_types (
  item             UUID     NOT NULL,
  type_declaration INTEGER  NOT NULL,

  PRIMARY KEY (item, type_declaration),

  CONSTRAINT item_types_item_exists
    FOREIGN KEY (item) REFERENCES items (item_id),

  CONSTRAINT item_types_declaration_exists
    FOREIGN KEY (type_declaration) REFERENCES metadata_type_declarations (id)
)
]]></Statement>

    <Statement>
      GRANT SELECT, INSERT, UPDATE, DELETE ON item_types TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON item_types TO cardant_read_only
    </Statement>

    <Comment>
      The item_attachments table contains attachments for each item.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE item_attachments (
  file_id   UUID         NOT NULL,
  item_id   UUID         NOT NULL,
  relation  VARCHAR(128) NOT NULL,

  CONSTRAINT FILE_EXISTS
    FOREIGN KEY (file_id) REFERENCES files (id),

  CONSTRAINT ITEM_EXISTS
    FOREIGN KEY (item_id) REFERENCES items (item_id),

  PRIMARY KEY (file_id, item_id, relation)
)
]]></Statement>

    <Statement>
      GRANT SELECT, INSERT, UPDATE, DELETE ON item_attachments TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON item_attachments TO cardant_read_only
    </Statement>

    <Comment>
      The item_metadata table contains metadata for each item.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE item_metadata (
  metadata_item_id  UUID          NOT NULL,
  metadata_name     VARCHAR(1024) NOT NULL,
  metadata_value    VARCHAR(1024) NOT NULL,

  CONSTRAINT metadata_name_VALID
    CHECK (metadata_name ~ '^([a-z][a-z0-9_-]{0,63})(\.[a-z][a-z0-9_-]{0,62}){0,15}$'),

  CONSTRAINT metadata_item_exists
    FOREIGN KEY (metadata_item_id) REFERENCES items (item_id),

  CONSTRAINT metadata_name_UNIQUE
    UNIQUE (metadata_item_id, metadata_name)
)
]]></Statement>

    <Statement>
      GRANT SELECT, INSERT, UPDATE, DELETE ON item_metadata TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON item_metadata TO cardant_read_only
    </Statement>

    <Comment>
      The metadata_element_t type holds a metadata value. This type is used as a
      strongly-typed container for values during search operations.
    </Comment>

    <Statement><![CDATA[
-- [jooq ignore start]
CREATE TYPE metadata_element_t AS (
  name  VARCHAR(1024),
  value VARCHAR(1024)
)
-- [jooq ignore stop]
]]></Statement>

    <Comment>
      The locations table contains storage/deployment locations for each item.
    </Comment>

    <StatementParameterized parameterInterpolation="STRING_FORMATTING">
      <ParameterReferences>
        <ParameterReference order="0"
                            name="search.language"/>
      </ParameterReferences>
      <Text><![CDATA[
CREATE TABLE locations (
  location_id           UUID          NOT NULL PRIMARY KEY,
  location_parent       UUID,
  location_name         VARCHAR(128)  NOT NULL,
  location_description  VARCHAR(1024) NOT NULL,

  -- [jooq ignore start]
  location_description_search TSVECTOR NOT NULL GENERATED ALWAYS AS (to_tsvector(%S, location_description)) STORED,
  -- [jooq ignore stop]

  CONSTRAINT location_parent_exists
    FOREIGN KEY (location_parent) REFERENCES locations (location_id)
)
]]></Text>
    </StatementParameterized>

    <Statement>
      GRANT SELECT, INSERT, UPDATE, DELETE ON locations TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON locations TO cardant_read_only
    </Statement>

    <Comment>
      The location_types table associates locations with types.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE location_types (
  location         UUID     NOT NULL,
  type_declaration INTEGER  NOT NULL,

  PRIMARY KEY (location, type_declaration),

  CONSTRAINT location_types_location_exists
    FOREIGN KEY (location) REFERENCES locations (location_id),

  CONSTRAINT location_types_declaration_exists
    FOREIGN KEY (type_declaration) REFERENCES metadata_type_declarations (id)
)
]]></Statement>

    <Statement>
      GRANT SELECT, INSERT, UPDATE, DELETE ON location_types TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON location_types TO cardant_read_only
    </Statement>

    <Statement><![CDATA[
CREATE TABLE item_locations (
  item_id       UUID   NOT NULL,
  item_location UUID   NOT NULL,
  count         BIGINT NOT NULL,

  PRIMARY KEY (item_id, item_location),

  CONSTRAINT item_id_exists
    FOREIGN KEY (item_id) REFERENCES items (item_id),

  CONSTRAINT item_location_exists
    FOREIGN KEY (item_location) REFERENCES locations (location_id),

  CONSTRAINT CHECK_item_location_COUNT CHECK (count >= 0)
)
]]></Statement>

    <Statement>
      GRANT SELECT, INSERT, UPDATE, DELETE ON item_locations TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON item_locations TO cardant_read_only
    </Statement>

    <Statement><![CDATA[
CREATE VIEW item_locations_summed (item_id, ITEM_COUNT)
  AS SELECT il.item_id, SUM (il.count) FROM item_locations AS il
    GROUP BY il.item_id
]]></Statement>

    <Statement>
      GRANT SELECT ON item_locations_summed TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON item_locations_summed TO cardant_read_only
    </Statement>

    <Comment>
      The location_descendants function returns the descendants of a given
      location. The location itself is included in the results.
    </Comment>

    <Statement><![CDATA[
CREATE FUNCTION location_descendants (X UUID)
  RETURNS TABLE (LOCATION UUID)
  LANGUAGE SQL
  AS
$$
WITH RECURSIVE location_tree AS (
  SELECT
    locations.location_parent,
    locations.location_id
  FROM locations
  WHERE
    locations.location_parent = X
  UNION
    SELECT
      L.location_parent,
      L.location_id
    FROM locations L
    JOIN location_tree
      ON location_tree.location_id = L.location_parent
)
SELECT
  location_id
FROM location_tree
UNION
  SELECT Q.location_id
    FROM locations Q
    WHERE Q.location_id = X
$$
]]></Statement>

    <Comment>
      The location_descendants function returns the descendants of a given
      location. The location itself is not included in the results.
    </Comment>

    <Statement><![CDATA[
CREATE FUNCTION location_descendants_strict (X UUID)
  RETURNS TABLE (LOCATION UUID)
  LANGUAGE SQL
  AS
$$
WITH RECURSIVE location_tree AS (
  SELECT
    locations.location_parent,
    locations.location_id
  FROM locations
  WHERE
    locations.location_parent = X
  UNION
    SELECT
      L.location_parent,
      L.location_id
    FROM locations L
    JOIN location_tree
      ON location_tree.location_id = L.location_parent
)
SELECT location_id FROM location_tree
$$
]]></Statement>

    <Comment>
      The location_is_descendant_of function returns true if x is a descendant
      of y in terms of the locations table.
    </Comment>

    <Statement><![CDATA[
CREATE FUNCTION location_is_descendant_of(
  X UUID,
  Y UUID
) RETURNS BOOL
  LANGUAGE PLPGSQL
  AS $$
BEGIN
  IF X = Y THEN
    RETURN TRUE;
  END IF;

  DECLARE
    YP UUID;
  BEGIN
    SELECT location_parent INTO YP FROM locations WHERE location_id = Y;
    RETURN location_is_descendant_of (X, YP);
  END;
END
$$
]]></Statement>

    <Comment>
      The audit table stores a list of auditable events. Who did it? What did
      they do? When did they do it?
    </Comment>

    <Statement><![CDATA[
CREATE TABLE audit (
  id      BIGINT                   NOT NULL PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  user_id UUID                     NOT NULL,
  time    TIMESTAMP WITH TIME ZONE NOT NULL,
  type    VARCHAR(1000000)         NOT NULL,
  message VARCHAR(1000000)         NOT NULL
)
]]></Statement>

    <Statement>
      GRANT SELECT, INSERT ON audit TO cardant
    </Statement>
    <Statement>
      GRANT SELECT ON audit TO cardant_read_only
    </Statement>
  </Schema>
</Schemas>
